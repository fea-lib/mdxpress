// MDX validation and filtering script
// Usage: node scripts/mdx-validate.cjs

const fs = require("fs");
const path = require("path");
const { createRequire } = require("module");

(async () => {
  const mdx = await import("@mdx-js/mdx");

  const DOCS_DIR = path.resolve(__dirname, "../src/docs");
  const GENERATED_DIR = path.resolve(__dirname, "../src/generated");
  if (!fs.existsSync(GENERATED_DIR)) fs.mkdirSync(GENERATED_DIR);
  const INVALID_OUTPUT_PATH = path.resolve(
    GENERATED_DIR,
    "invalidMdxFiles.json"
  );
  const requireModule = createRequire(__filename);

  // Recursively find all .mdx files in docs
  function findMdxFiles(dir) {
    let results = [];
    for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
      const fullPath = path.join(dir, entry.name);
      let isDir = entry.isDirectory();
      if (entry.isSymbolicLink()) {
        // Resolve symlink and check if target is a directory
        try {
          const realPath = fs.realpathSync(fullPath);
          isDir = fs.statSync(realPath).isDirectory();
        } catch (e) {
          continue;
        }
      }
      if (isDir) {
        results = results.concat(findMdxFiles(fullPath));
      } else if (entry.isFile() && entry.name.endsWith(".mdx")) {
        results.push(fullPath);
      }
    }
    return results;
  }

  // Extract import sources from MDX file
  function getImports(filePath) {
    const content = fs.readFileSync(filePath, "utf8");
    const importRegex = /import\s+[^'";]+['"]([^'"\)]+)['"]/g;
    const imports = [];
    let match;
    while ((match = importRegex.exec(content))) {
      imports.push(match[1]);
    }
    return imports;
  }

  // Check if all imports are resolvable and file is valid MDX
  function isValidMdx(filePath) {
    const imports = getImports(filePath);
    // Helper to check tsconfig.json extends
    function checkTsconfigExtends(tsconfigPath) {
      try {
        const tsconfig = JSON.parse(fs.readFileSync(tsconfigPath, "utf8"));
        if (typeof tsconfig.extends === "string") {
          let base = tsconfig.extends;
          // Try to resolve as a module or as a file
          try {
            requireModule.resolve(base);
          } catch {
            // Try as relative to tsconfig
            const rel = path.resolve(path.dirname(tsconfigPath), base);
            if (!fs.existsSync(rel) && !fs.existsSync(rel + ".json")) {
              return false;
            }
          }
        }
      } catch {
        return false;
      }
      return true;
    }

    // Check all imports
    for (const imp of imports) {
      if (imp.startsWith(".")) {
        // Relative import: check file exists (try .js, .jsx, .ts, .tsx, .mdx, and no extension)
        const relPath = path.resolve(path.dirname(filePath), imp);
        const candidates = [
          relPath,
          relPath + ".js",
          relPath + ".jsx",
          relPath + ".ts",
          relPath + ".tsx",
          relPath + ".mdx",
        ];
        const found = candidates.find(fs.existsSync);
        if (!found) {
          return false;
        }
        // If the import is a TS/JSX/TSX file, check tsconfig.json extends
        if (found && /\.(ts|tsx|jsx)$/.test(found)) {
          // Look for tsconfig.json in the same dir or parent dirs
          let dir = path.dirname(found);
          let tsconfigPath = null;
          for (let i = 0; i < 5; ++i) {
            // limit search depth
            const candidate = path.join(dir, "tsconfig.json");
            if (fs.existsSync(candidate)) {
              tsconfigPath = candidate;
              break;
            }
            const parent = path.dirname(dir);
            if (parent === dir) break;
            dir = parent;
          }
          if (tsconfigPath && !checkTsconfigExtends(tsconfigPath)) {
            return false;
          }
        }
      } else {
        // Dependency import: check resolvable from node_modules
        try {
          requireModule.resolve(imp);
        } catch {
          return false;
        }
      }
    }
    // Check MDX syntax
    try {
      const content = fs.readFileSync(filePath, "utf8");
      mdx.compileSync(content);
    } catch (e) {
      return false;
    }
    return true;
  }

  const allMdx = findMdxFiles(DOCS_DIR);
  const invalidMdx = [];
  for (const file of allMdx) {
    if (!isValidMdx(file)) {
      invalidMdx.push(file);
    }
  }

  // Write the list of invalid MDX files (relative to docs dir)
  let relInvalidMdx = invalidMdx.map((f) => path.relative(DOCS_DIR, f));

  // Write the list of valid MDX files (relative to docs dir)
  const relValidMdx = allMdx
    .filter((f) => !invalidMdx.includes(f))
    .map((f) => path.relative(DOCS_DIR, f));

  // Generate validMdxGlobs.generated.ts as an object of import functions
  const VALID_GLOBS_PATH = path.resolve(
    GENERATED_DIR,
    "validMdxGlobs.generated.ts"
  );
  const globsContent = `// AUTO-GENERATED FILE. DO NOT EDIT.\n// Generated by scripts/mdx-validate.cjs\nexport const mdxModules = {\n${relValidMdx
    .map((f) => `  "/src/docs/${f}": () => import("/src/docs/${f}"),`)
    .join("\n")}\n};\n`;
  fs.writeFileSync(VALID_GLOBS_PATH, globsContent);

  fs.writeFileSync(INVALID_OUTPUT_PATH, JSON.stringify(relInvalidMdx, null, 2));

  // Write the list of valid MDX files (relative to docs dir)
  const VALID_OUTPUT_PATH = path.resolve(GENERATED_DIR, "validMdxFiles.json");
  fs.writeFileSync(VALID_OUTPUT_PATH, JSON.stringify(relValidMdx, null, 2));
})();
